// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'single_post_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$SinglePostState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() singlePostloading,
    required TResult Function(SingleDataWrapper posts) singlePostSuccess,
    required TResult Function(ErrorHandler errorHandler) singlePosterror,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? singlePostloading,
    TResult? Function(SingleDataWrapper posts)? singlePostSuccess,
    TResult? Function(ErrorHandler errorHandler)? singlePosterror,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? singlePostloading,
    TResult Function(SingleDataWrapper posts)? singlePostSuccess,
    TResult Function(ErrorHandler errorHandler)? singlePosterror,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SinglePostloading value) singlePostloading,
    required TResult Function(_SinglePostSuccess value) singlePostSuccess,
    required TResult Function(_SinglePostError value) singlePosterror,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SinglePostloading value)? singlePostloading,
    TResult? Function(_SinglePostSuccess value)? singlePostSuccess,
    TResult? Function(_SinglePostError value)? singlePosterror,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SinglePostloading value)? singlePostloading,
    TResult Function(_SinglePostSuccess value)? singlePostSuccess,
    TResult Function(_SinglePostError value)? singlePosterror,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SinglePostStateCopyWith<$Res> {
  factory $SinglePostStateCopyWith(
    SinglePostState value,
    $Res Function(SinglePostState) then,
  ) = _$SinglePostStateCopyWithImpl<$Res, SinglePostState>;
}

/// @nodoc
class _$SinglePostStateCopyWithImpl<$Res, $Val extends SinglePostState>
    implements $SinglePostStateCopyWith<$Res> {
  _$SinglePostStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SinglePostState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
    _$InitialImpl value,
    $Res Function(_$InitialImpl) then,
  ) = __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$SinglePostStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
    _$InitialImpl _value,
    $Res Function(_$InitialImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SinglePostState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'SinglePostState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() singlePostloading,
    required TResult Function(SingleDataWrapper posts) singlePostSuccess,
    required TResult Function(ErrorHandler errorHandler) singlePosterror,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? singlePostloading,
    TResult? Function(SingleDataWrapper posts)? singlePostSuccess,
    TResult? Function(ErrorHandler errorHandler)? singlePosterror,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? singlePostloading,
    TResult Function(SingleDataWrapper posts)? singlePostSuccess,
    TResult Function(ErrorHandler errorHandler)? singlePosterror,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SinglePostloading value) singlePostloading,
    required TResult Function(_SinglePostSuccess value) singlePostSuccess,
    required TResult Function(_SinglePostError value) singlePosterror,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SinglePostloading value)? singlePostloading,
    TResult? Function(_SinglePostSuccess value)? singlePostSuccess,
    TResult? Function(_SinglePostError value)? singlePosterror,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SinglePostloading value)? singlePostloading,
    TResult Function(_SinglePostSuccess value)? singlePostSuccess,
    TResult Function(_SinglePostError value)? singlePosterror,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements SinglePostState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$SinglePostloadingImplCopyWith<$Res> {
  factory _$$SinglePostloadingImplCopyWith(
    _$SinglePostloadingImpl value,
    $Res Function(_$SinglePostloadingImpl) then,
  ) = __$$SinglePostloadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SinglePostloadingImplCopyWithImpl<$Res>
    extends _$SinglePostStateCopyWithImpl<$Res, _$SinglePostloadingImpl>
    implements _$$SinglePostloadingImplCopyWith<$Res> {
  __$$SinglePostloadingImplCopyWithImpl(
    _$SinglePostloadingImpl _value,
    $Res Function(_$SinglePostloadingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SinglePostState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SinglePostloadingImpl implements _SinglePostloading {
  const _$SinglePostloadingImpl();

  @override
  String toString() {
    return 'SinglePostState.singlePostloading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SinglePostloadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() singlePostloading,
    required TResult Function(SingleDataWrapper posts) singlePostSuccess,
    required TResult Function(ErrorHandler errorHandler) singlePosterror,
  }) {
    return singlePostloading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? singlePostloading,
    TResult? Function(SingleDataWrapper posts)? singlePostSuccess,
    TResult? Function(ErrorHandler errorHandler)? singlePosterror,
  }) {
    return singlePostloading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? singlePostloading,
    TResult Function(SingleDataWrapper posts)? singlePostSuccess,
    TResult Function(ErrorHandler errorHandler)? singlePosterror,
    required TResult orElse(),
  }) {
    if (singlePostloading != null) {
      return singlePostloading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SinglePostloading value) singlePostloading,
    required TResult Function(_SinglePostSuccess value) singlePostSuccess,
    required TResult Function(_SinglePostError value) singlePosterror,
  }) {
    return singlePostloading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SinglePostloading value)? singlePostloading,
    TResult? Function(_SinglePostSuccess value)? singlePostSuccess,
    TResult? Function(_SinglePostError value)? singlePosterror,
  }) {
    return singlePostloading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SinglePostloading value)? singlePostloading,
    TResult Function(_SinglePostSuccess value)? singlePostSuccess,
    TResult Function(_SinglePostError value)? singlePosterror,
    required TResult orElse(),
  }) {
    if (singlePostloading != null) {
      return singlePostloading(this);
    }
    return orElse();
  }
}

abstract class _SinglePostloading implements SinglePostState {
  const factory _SinglePostloading() = _$SinglePostloadingImpl;
}

/// @nodoc
abstract class _$$SinglePostSuccessImplCopyWith<$Res> {
  factory _$$SinglePostSuccessImplCopyWith(
    _$SinglePostSuccessImpl value,
    $Res Function(_$SinglePostSuccessImpl) then,
  ) = __$$SinglePostSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SingleDataWrapper posts});
}

/// @nodoc
class __$$SinglePostSuccessImplCopyWithImpl<$Res>
    extends _$SinglePostStateCopyWithImpl<$Res, _$SinglePostSuccessImpl>
    implements _$$SinglePostSuccessImplCopyWith<$Res> {
  __$$SinglePostSuccessImplCopyWithImpl(
    _$SinglePostSuccessImpl _value,
    $Res Function(_$SinglePostSuccessImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SinglePostState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? posts = null}) {
    return _then(
      _$SinglePostSuccessImpl(
        posts:
            null == posts
                ? _value.posts
                : posts // ignore: cast_nullable_to_non_nullable
                    as SingleDataWrapper,
      ),
    );
  }
}

/// @nodoc

class _$SinglePostSuccessImpl implements _SinglePostSuccess {
  const _$SinglePostSuccessImpl({required this.posts});

  @override
  final SingleDataWrapper posts;

  @override
  String toString() {
    return 'SinglePostState.singlePostSuccess(posts: $posts)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SinglePostSuccessImpl &&
            (identical(other.posts, posts) || other.posts == posts));
  }

  @override
  int get hashCode => Object.hash(runtimeType, posts);

  /// Create a copy of SinglePostState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SinglePostSuccessImplCopyWith<_$SinglePostSuccessImpl> get copyWith =>
      __$$SinglePostSuccessImplCopyWithImpl<_$SinglePostSuccessImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() singlePostloading,
    required TResult Function(SingleDataWrapper posts) singlePostSuccess,
    required TResult Function(ErrorHandler errorHandler) singlePosterror,
  }) {
    return singlePostSuccess(posts);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? singlePostloading,
    TResult? Function(SingleDataWrapper posts)? singlePostSuccess,
    TResult? Function(ErrorHandler errorHandler)? singlePosterror,
  }) {
    return singlePostSuccess?.call(posts);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? singlePostloading,
    TResult Function(SingleDataWrapper posts)? singlePostSuccess,
    TResult Function(ErrorHandler errorHandler)? singlePosterror,
    required TResult orElse(),
  }) {
    if (singlePostSuccess != null) {
      return singlePostSuccess(posts);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SinglePostloading value) singlePostloading,
    required TResult Function(_SinglePostSuccess value) singlePostSuccess,
    required TResult Function(_SinglePostError value) singlePosterror,
  }) {
    return singlePostSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SinglePostloading value)? singlePostloading,
    TResult? Function(_SinglePostSuccess value)? singlePostSuccess,
    TResult? Function(_SinglePostError value)? singlePosterror,
  }) {
    return singlePostSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SinglePostloading value)? singlePostloading,
    TResult Function(_SinglePostSuccess value)? singlePostSuccess,
    TResult Function(_SinglePostError value)? singlePosterror,
    required TResult orElse(),
  }) {
    if (singlePostSuccess != null) {
      return singlePostSuccess(this);
    }
    return orElse();
  }
}

abstract class _SinglePostSuccess implements SinglePostState {
  const factory _SinglePostSuccess({required final SingleDataWrapper posts}) =
      _$SinglePostSuccessImpl;

  SingleDataWrapper get posts;

  /// Create a copy of SinglePostState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SinglePostSuccessImplCopyWith<_$SinglePostSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SinglePostErrorImplCopyWith<$Res> {
  factory _$$SinglePostErrorImplCopyWith(
    _$SinglePostErrorImpl value,
    $Res Function(_$SinglePostErrorImpl) then,
  ) = __$$SinglePostErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ErrorHandler errorHandler});
}

/// @nodoc
class __$$SinglePostErrorImplCopyWithImpl<$Res>
    extends _$SinglePostStateCopyWithImpl<$Res, _$SinglePostErrorImpl>
    implements _$$SinglePostErrorImplCopyWith<$Res> {
  __$$SinglePostErrorImplCopyWithImpl(
    _$SinglePostErrorImpl _value,
    $Res Function(_$SinglePostErrorImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SinglePostState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? errorHandler = null}) {
    return _then(
      _$SinglePostErrorImpl(
        null == errorHandler
            ? _value.errorHandler
            : errorHandler // ignore: cast_nullable_to_non_nullable
                as ErrorHandler,
      ),
    );
  }
}

/// @nodoc

class _$SinglePostErrorImpl implements _SinglePostError {
  const _$SinglePostErrorImpl(this.errorHandler);

  @override
  final ErrorHandler errorHandler;

  @override
  String toString() {
    return 'SinglePostState.singlePosterror(errorHandler: $errorHandler)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SinglePostErrorImpl &&
            (identical(other.errorHandler, errorHandler) ||
                other.errorHandler == errorHandler));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorHandler);

  /// Create a copy of SinglePostState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SinglePostErrorImplCopyWith<_$SinglePostErrorImpl> get copyWith =>
      __$$SinglePostErrorImplCopyWithImpl<_$SinglePostErrorImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() singlePostloading,
    required TResult Function(SingleDataWrapper posts) singlePostSuccess,
    required TResult Function(ErrorHandler errorHandler) singlePosterror,
  }) {
    return singlePosterror(errorHandler);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? singlePostloading,
    TResult? Function(SingleDataWrapper posts)? singlePostSuccess,
    TResult? Function(ErrorHandler errorHandler)? singlePosterror,
  }) {
    return singlePosterror?.call(errorHandler);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? singlePostloading,
    TResult Function(SingleDataWrapper posts)? singlePostSuccess,
    TResult Function(ErrorHandler errorHandler)? singlePosterror,
    required TResult orElse(),
  }) {
    if (singlePosterror != null) {
      return singlePosterror(errorHandler);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SinglePostloading value) singlePostloading,
    required TResult Function(_SinglePostSuccess value) singlePostSuccess,
    required TResult Function(_SinglePostError value) singlePosterror,
  }) {
    return singlePosterror(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SinglePostloading value)? singlePostloading,
    TResult? Function(_SinglePostSuccess value)? singlePostSuccess,
    TResult? Function(_SinglePostError value)? singlePosterror,
  }) {
    return singlePosterror?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SinglePostloading value)? singlePostloading,
    TResult Function(_SinglePostSuccess value)? singlePostSuccess,
    TResult Function(_SinglePostError value)? singlePosterror,
    required TResult orElse(),
  }) {
    if (singlePosterror != null) {
      return singlePosterror(this);
    }
    return orElse();
  }
}

abstract class _SinglePostError implements SinglePostState {
  const factory _SinglePostError(final ErrorHandler errorHandler) =
      _$SinglePostErrorImpl;

  ErrorHandler get errorHandler;

  /// Create a copy of SinglePostState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SinglePostErrorImplCopyWith<_$SinglePostErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
